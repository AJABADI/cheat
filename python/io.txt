# Special variables
os.getcwd()  // current working directory
os.linesep // new line

# Reading from stdin / stderrr
not sys.stdout.isatty() // file.py | cmd; file.py > out
not sys.stderr.isatty() // file.py 2> err
not sys.stdin.isatty()  // cmd | file.py
if not sys.stdin.isatty():
  for line in sys.stdin:
    ...
  lines = [x.strip() for x in sys.stdin.readlines()] // 'line1\n', 'line2\n'

# file
## Reading content
f = open(filename, 'rwa')
with open(filename) as f: // will be closed at the end
  f.read()
f.read()  // read everything as single string
f.readline()  // f.readline() == 'line\n'; '' == eof; '\n' is empty line
for line in f:  // read line by line
lines = open(filename).read().splitlines() // read all lines in array
f.readlines() // read all lines in array()
lines = [l.rstrip() for l in open(filename, 'r')]

## Misc
f.close()
f.seek(0) // reopen file

## Checking eof
f.readline() == ''
f.tell() = tell_previous

# Grep lines from file
file = open(...)
for line in file:
  m = re.search('.../([^/]+)/...')
  if m:
    lines.append(m.group(1))


# File names
os.path
join(a, b, c)
splitext('/d/f.ext') -> ['/d/f', 'ext']
splitexit(path)[0]  // remove extension
path.split(os.extsep, 1) // file.abc.def -> [file, 'abc.def']
extsep == '.' // character extension separator
f.split(extsep)[0]  // split ext with multiple '.'
basename(path)
dirname(path)
os.sep // path separtor -> '/' for Linux
path.split(os.sep) // /dir1/dir2/dir3 -> dir1, dir2, dir3
abspath(__file__)
realpath()  // like abspath, but resolves symlinks
expanduser('~')
getenv('HOME', ...) // environment variables
  default=
user = getpass.getuser()


# Misc
os.listdir('.') // list all files in directory
for root, dirs, files in os.walk(dirname) // traverse all files in dirname recursively
os.getcwd()  // current working directory
os.chdir(dir) // change working directory
import glob
glob.glob('dir/*.py')
os.remove(file) // remove/delete file
os.rmdir(dir) // remove/delete EMPTY dir; see shutil.rmtree
import shutil
shutil.copyfile(src, dst) // copy file
shutil.copytree(src_dir, dst_dir) // copy dir
shutil.move(src, dst) // rename, move file like mv
shutil.rmtree(path) // remove dir with content




# execute system/shell command
rv = os.system(cmd) // deprecated

import subprocess as sp
rv = sp.call(['ls', '-l'], ...) // returns exit state
  ... // arguments passed to sp.Popen(...)

## capturing output
sp.Popen(cmd, stdout=sp.PIPE).stdout.read()
sp.Popen(cmd, shell=True, cwd=os.getcwd(), stdout=sp.PIPE).stdout.read().decode().splitlines()
sp.check_output(cmd)  // like Popen, but Exception if $? != 0
sp.check_output(cmd, shell=True).decode().splitlines()



# check if exsits
os.path.
exists(f) // file or directory
isfile(f) // is file
isdir(f)  // is directory


# create
os.makedirs('d1/d2', exist_ok=True) // mkdir -p; exist_ok only Python3
  * NOTE: not mkdir!



# Temporary files
import tempfile
fd, path, name = mkstemp(...) // path is abs filename; fd is int file id
  prefix='abc'
  suffix='.h5'
  dir=tempfile.gettempdir()
path = mkdtemp(dir=, prefix=, suffix=)  // create temp dir and return rel path
gettempdir() // '/tmp'


# String file
from io import StringIO
f = StringIO('hello\nworld')
f.read()


# comparing files
import filecmp
cmp('file1', 'file2') // True if files are equal
cmpfiles(dir1, dir2, commom=[file1, file2]) // Compare files in directories
  returns (a, b, c)
    a // list of files in common that are equal
    b // list of files in common that are unequal
    c // list of files in common that non-regular files


# User input / ask confirmation
return raw_input().lower() in ['y', 'yes']


# Hostname
import socket; socket.gethostname()
os.getenv('HOSTNAME')


# Working with binary files / data
f = open(path, 'rb')
b = f.read(num_bytes)
  * Returns str() for python2
  * Returns bytes()/b"xxx" for python3
my_int = int.from_bytes(bytes, byteorder=sys.byteorder, signed=False)
  * sys.byteorder in ['little', 'big']


## Using struct for encoding / decoding
>>> import struct
>>> struct.pack('f', 3.141592654)
b'\xdb\x0fI@'
>>> struct.unpack('f', b'\xdb\x0fI@')
(3.1415927410125732,)
>>> struct.pack('4f', 1.0, 2.0, 3.0, 4.0)
'\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@'
