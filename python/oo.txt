# Special methods
http://docs.python.org/2/reference/datamodel.html#special-method-names
__init__  // constructor
__del__   // destructor
__getitem__ // a[i]
__setitem__ // a[i] = v
__len__   // len(a)
__repr_   // unique representation of object
__str__   // readable representation; str(s)
__add__   // a + b
__sub__   // a - b
__cmp__   // a == b
__call__(self, x)  // object(x); call object as function

# Special variables
__dir__
  * all object names: __init__, method(), __str__(), ...
  * dir(Class)
  * list()
__dict__
  * class variables: __doc__ (not methods)
  * vars(Class)
  * type(__dict__) == mappingproxy
  * type(dict(__dict)) == dict
  * o.__dict__['attr'] = value  // change attribute


# Private: double underscore
__private_constant
__private_method

# Copying instances
import copy
copy.copy(x)
copy.deepcopy(x)

# Getting, setting attributes
o = Class()
hasattr(o, 'a')
getattr(o, 'a')
setattr(o, 'a', v)
dir(o)  // list attributes

# overriding
class Parent(object):
  def __init__(self, a):
    self.a = a

class Child(Parent):

c = Child(1)
  * Inherits constructor of parent!
  * Requires a argument!

## overriding constructor and methods
class Child(Parent):
  def __init__(self, a, **kwargs):
    self.a = a
    super(Child, self).__init__(*kwargs)  // call parent constructor

  def method(self):
    super(Child, self).method() // call parent method


# Decorators
@staticmethod
def static():
  // Class.static() or object.static()
  // no self (class) argument
  // like static C++ 

@classmethod
def static(self):
  // Class.static() or object.static()
  // has self (class) argument


# Multiple constructors
class Class:
  def __init__(self, data):
    default constructor

  @classmethod
  def from_data(cls, filename):
    data = read(filename)
    cls(data)
    

# Generator
class Generator(object):
  def __init__(n):  // construct
  def __iter__(self): // initialize
    return self
  def __next__(self): // return next element
    raise StopIteration()
  def next(self): // Python2 backward compatibility
      return self.__next__()

for x in gen:
  ...
iter(gen) // calls __init__(); resets iterator
x = next(gen) // calls __next__()


# Iterator function --> yield to construct generator
def fibonacci(n):
    # proceed at yield() when function is called again
    # function with yield() generators iterator if __next__() method
    a = 0
    b = 1
    for i in range(n):
        c = a + b
        if i >= 1:
            a = b
            b = c
        yield c
