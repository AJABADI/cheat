# Special methods
http://docs.python.org/2/reference/datamodel.html#special-method-names
__init__  // constructor
__del__   // destructor
__getitem__ // a[i]
__setitem__ // a[i] = v
__len__   // len(a)
__repr_   // unique representation of object
__str__   // readable representation; str(s)
__add__   // a + b
__sub__   // a - b
__cmp__   // a == b

# Special variables
__dir__
  * all object names: __init__, method(), __str__(), ...
  * dir(Class)
  * list()
__dict__
  * class variables: __doc__ (not methods)
  * vars(Class)
  * type(__dict__) == mappingproxy
  * type(dict(__dict)) == dict
  * o.__dict__['attr'] = value  // change attribute


# Private: double underscore
__private_constant
__private_method

# Copying instances
import copy
copy.copy(x)
copy.deepcopy(x)

# Getting, setting attributes
o = Class()
hasattr(o, 'a')
getattr(o, 'a')
setattr(o, 'a', v)
dir(o)  // list attributes

# overriding
class Parent(object):
  def __init__(self, a):
    self.a = a

class Child(Parent):

c = Child(1)
  * Inherits constructor of parent!
  * Requires a argument!

## overriding constructor and methods
class Child(Parent):
  def __init__(self, a, **kwargs):
    self.a = a
    super(Child, self).__init__(*kwargs)  // call parent constructor

  def method(self):
    super(Child, self).method() // call parent method


# decorators
@staticmethod
def f(arg):
* No implicit first argument
* ref = Class.f // class is not bound

@classmethod
def f(cls, arg)
* cls as implicit first argument
* ref = Class.f // unbound



# Static class methods
@staticmethod
def class_info():
  return 'Class information'

# Multiple constructors
class Class:
  def __init__(self, data):
    default constructor

  @classmethod
  def from_data(cls, filename):
    data = read(filename)
    cls(data)
    

