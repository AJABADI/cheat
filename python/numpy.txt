# Contingency/pivot table
pandas.crosstab(y, x)

# Mean with nan
## scipy
scipy.stats.nanman(a, axis=1)
## masked_array
ma = np.ma.masked_array(a, mask=np.isnan(a))
np.mean(ma, axis=1)

# Resizing arrays
a.resize((3, 5))  // changes shape a inplace; fills with zero
np.resize(a, (3, 5)) // returns copy; fills with values/copies of a

# keep dimension after slicing
atleast_1d(a[0, 0])
atleat_2d(a[0, :])

# Masked array
import numpy.ma as ma
n = np.array
m = ma.masked_array([1, 2, 3], [0, 0, 1]) // 3 is masked
m = ma.masked_values(n, 3)  // mask value 3 in numpy array
m[i, j] = ma.masked // mask value
m.data  // original data
m.mask  // mask
m[~m.mask]  // return view on existing values
m.compressed()  // return new numpy array only with existing values
m[i, j] = ma.masked // mask value
m[i, j] is ma.masked
np.mean(m)  // only for existing values
np.log(m) // return masked array

# nan/inf
nan // not a number
inf // infinite
a = array([1, nan, inf])
a.dtype // float64
ianan(a)
isinf(a)







# Efficiency
C-order: matrix stored row by row in memory // default numpy
F-oder: matrix stored column by column  // fortran
A = array(order='F')
A.stride  // stide: bytes to go to next axis
np.max(list) is bad!  // do not use np functions on lists - conversion to array

## Matrix to vector
flatten // returns copy
ravel // return reference
squeeze // remove single entry dimensions; column vector -> row vector

A.take([1, 2], axis=0)  // select slices along axis
A.compress([1, 2], axis=0)  // select slices along axis


# Apply function over axis
np.apply_along_axis(fun, axis, array) 0 == columns! // returns numpy array
r = [fun(row) for row in array] // returns list

# Data type, dtype
int16 'i2'
float8  'f8'
str 'S10' == 'a10'  // str length 10
x.astype(np.float16)  // change dtype
x.view(np.float16)  // change view on dtype

# Structure array
a = np.empty((3, ), dtype=('i4, f4, a10'))  // unlabeled
a[0] = (1, 1.2, 'name')
a = np.empty((3, ), dtype=np.dtype([('id', 'i4'), ('name', 'a10')])) // labeled
np.empty((3, ), np.dtype([('name', 'S16'), ('value', 'f32')]))

# Conversion to matlab
import scipi.io as io
io.savemat('file.mat', {'a':a, 'b':b})
## Cell array
cell = np.empty((n, m), dtype=np.object)
cell[i, j] = np.ones((3, 4))

# Indexing arrays
a[a > b]  // logical numpy array; not supported by default arrays

# Broadcasting
A = np.random.rand(3, 5)
b = np.arange(5)
A + b  // add row vector to each row
A + b[:,np.newaxis] // add column vector to each column
## Broadcasting rule
5 x 3 x 2
        2
5 x 3 x 2
        2

# setting options
np.set_printoption(linewidth=100, precision=4)
np.get_printoption(linewidth)
np.seterr(all=, divide=, under=, over=, divide=, invalid=)  // errors, warnings, exceptions
  ['ignore', 'warn', 'print', 'raise']
np.geterr()

# ndarray
array class
ndarray(shape, dtype, ...)
ndarray((3, 4))
## constructors
  array()
  empty()
  ones()
  zeros()
## attributes
a.size  // # elements
a.ndim  // # dimensions
a.shape
a.dtype
a.astype(float) // convert type

## initialization
arange(start, stop, step)
linspace(start, stop, num)
logspace(start, stop, num)
linspace(0, 10, 16).reshape((2, 8))
ones(5) // init vector
ones_like(M)  // the shape as M
repeat(5, n)  // repeat 5 n times
a = empty(5); a.fill(v) // fast way to fill with same value
ones((2, 8))
zeros((2, 8))
empty((2, 8))
identity(3)
eye(3)
diag([1, 2, 3]) // create diagonal matrix
diagonal(matrix)  // extract diagonal from matrix
b = a.copy(), b = np.copy(a)  // copy array
asarray([[1, 2, 3], [4, 4, 5]]))  // list -> nparray

## functions
insert(a, index, value)
delete(a, index)
append(a, value)
concatenate((a, b))
hstack((a, b))
vstack((a, b))
dstack((a, b))
.sort() // sort inplace
np.sort(a)  // sort outplace
np.sort(a)[::-1]  // sort reverse
.argsort()  // order

## operations
a1 * a2 // pairwise multiplication
multiply(a1, a2)  // pairwise multiplication
  multiply(1, 2) = 2
  multiply([1, 2], [3, 4])  = [3, 8]
  multiply(A, rowvector)  // scale columns
  multiply(A, columnvector) // scale rows
dot(a1, a2) // dot product
dot(m, a) // matrix vector product
m.dot(a)  // matrix vector product
sum, mean, var, std(a)  // of all elements
sum, mean, var, std(a, 0) // over all rows
sum(a, 0) // sum vertically (over rows)
sum(a, 1) // sum horizontally (over columns)
max, min
argmax(array, axis=), argmin  // maximum/minimum (along axis)

maximum(a, b) // pairwise maximum of two arrays
unique(a)

## io
save('data.npy', data)  // binary npy format
data = load('data.npy')
savez('data.npz', d1=d1, d2=d2) // save several objects in file
data = load('data.npz')
data['d1']; data['d2']
savetxt('data.csv', data, sep=',')
loadtxt('data.csv', sep=',')

## reshape
.reshape(3, 4)
.reshape(3, -1) // calculate missing dim
.flatten()  // matrix to vector
.ravel()  // flatten(), but reference if possible
a[:, newaxis] // vector to column vector
a.sqeeze()  // remove 1 dims, e.g. column vector to vector
hstack((a, b))  // concat left - right
vstack((a, b))  // concat top - down
concatenate((a, b), 0)  // concat -
hsplit(M, 4)  // split M into 4 parts |
vsplit(M, 4)  // split M into 4 parts -
repeat(a, n)  // repeat each element n times
tile(M, (3, 4)) // copy M 3x4

## boolean array
b = data[:, 5] > 5
b.sum()
b.any()
b.all()
b.nonzero()
where(b > 0)  // like R which(b > 0)

## vectorize function
vectorize(func)(a)  // calls func with each element of a


## comparison
array_equal // same shape and elements
array_equiv // similar shape and same elements
allclose // similar within tolerance

# mat: matrix
m = mat([[1, 2], [3, 4]])
mat('1 2; 3 4')
m.shape, shape(m) // dimension -> NOTE: attribute, no function
m[i,:]  // row vector
m[:,i]  // column vector
m * n // matrix product, not pairwise product!
m.T // transpose

# linalg
linalg.eig
linalg.det
linalg.inv
linalg.svd
linalg.norm(m, ord='norm')  // compute Frobenius norm of matrix
  sqrt(trace(m.transpose().dot(m)))
  sqrt(sum(sum(m**2)))
linalg.norm(v)  // Euclidean norm of vector
linalg.norm(m, axis=0) // Euclidean norm of all column vectors

# random
random.seed(0)
random.rand(x, y, z)  // ndarray from [0, 1]
random.randn(x, y, y) // ndarray form N(0, 1)
random.randint(low, high, size)
random.uniform(low, hight, size)
random.normal(mean, std, size)
np.shuffle(array) // shuffle entries inplace
np.random.choice(array, size, replace=False)  // sample (without) replacement from array

